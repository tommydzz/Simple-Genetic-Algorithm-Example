# README

小黄与罐子，简单的遗传算法实例

## 规则

小黄在一个10 * 10 大小的随机生成的地图中，50%为罐子，其余为空地，四周是围墙。撞墙扣5分，捡罐子加10分，捡空地扣2分

小黄一开始在地图左上角，走200步后统计最终分数，如何获得最优策略？每一个小黄的策略表长度为243,对应小黄可能看到的
3^5种情况.每个策略的值为0~6的整数,对应小黄可以做的7种动作.也就是说,有了这个策略表,小黄可以根据自己看到的情况做出唯一选择.

本项目用遗传算法，从原初完全随机的状态开始提高分数。

## 1. 项目结构

train文件夹内为训练程序，运用遗传算法进行训练，1000代后停止，训练成果存储在strategy.txt，训练过程存储在iteration.txt

auto文件夹内为展示程序，将读取strategy.txt内的策略表进行移动。

## 2. 实现思路

### 2.1 遗传算法训练程序

#### 2.1.1 一只的运行历程

首先，随机生成策略表，存入strategyTable这个六维数组中，第一维表示小黄的编号，剩余五维表示小黄周围格子的0，1，2的情况。随后获得小黄所处的周围环境传入策略表作为参数，执行该位置对应的策略。

#### 2.1.2 一代的运行历程

由于设置的策略表数组为六维，便可以很清晰地表示同一代中每一个小黄的策略表，只需遍历即可。在每一只小黄的执行过程中，生成100张地图算出均分并存入数组average[i]，并在该代所有小黄执行完毕后获得总体平均值ave。

#### 2.1.3 生成子代

本项目最为关键的部分。在一代运行过后，依据average[i]，对200只小黄的策略表从小到大排序，随后随机生成一个1到20100的随机数，遍历0到199的整数i，对应i * (i + 1) / 2 < a && a <= (i + 1) * (i + 2) / 2的随机数，并将其i作为父本，重复一次得到母本。之后便是基因重组，此处使用到了指针（维数过多，单纯数组难以操作），并考虑到了基因变异，同时每一代成绩最好的10组将会直接遗传给下一代。

#### 2.1.4 策略表与训练过程的输出

此处即使用c语言的文件读写功能，写入程序的训练过程以及程序最终最高分的策略表即可。

### 2.2 自动运行程序

这部分的内容比较简单，只需用fscanf读入策略，利用pj1中的printMaps函数进行自动行走即可。值得注意的是若是一直运行程序，会难以看清具体的执行过程，这时需要用usleep函数进行延时



